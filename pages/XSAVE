-   Index
-   December 2017



XSAVE — SAVE PROCESSOR EXTENDED STATES


  Opcode / Instruction                Op/En   64/32 bit Mode Support   CPUID Feature Flag   Description
  ----------------------------------- ------- ------------------------ -------------------- ------------------------------------------------------
  NP 0F AE /4 XSAVE _mem_             M       V/V                      XSAVE                Save state components specified by EDX:EAX to _mem_.
  NP REX.W + 0F AE /4 XSAVE64 _mem_   M       V/N.E.                   XSAVE                Save state components specified by EDX:EAX to _mem_.


Instruction Operand Encoding¶

  ------- --------------- ----------- ----------- -----------
  Op/En   Operand 1       Operand 2   Operand 3   Operand 4
  M       ModRM:r/m (w)   NA          NA          NA
  ------- --------------- ----------- ----------- -----------


Description¶

Performs a full or partial save of processor state components to the
XSAVE area located at the memory address specified by the destination
operand. The implicit EDX:EAX register pair specifies a 64-bit
instruction mask. The specific state components saved correspond to the
bits set in the requested-feature bitmap (RFBM), which is the
logical-AND of EDX:EAX and XCR0.

The format of the XSAVE area is detailed in Section 13.4, “XSAVE Area,”
of _Intel® 64 and IA-32 Architectures Software Developer’s Manual,
Volume 1_.

Section 13.7, “Operation of XSAVE,” of _Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1_ provides a detailed
description of the operation of the XSAVE instruction. The following
items provide a high-level outline:

-   XSAVE saves state component _i_ if and only if RFBM[_i_] = 1.¹
-   XSAVE does not modify bytes 511:464 of the legacy region of the
    XSAVE area (see Section 13.4.1, “Legacy Region of an XSAVE Area”).
-   XSAVE reads the XSTATE_BV field of the XSAVE header (see Section
    13.4.2, “XSAVE Header”) and writes a modified value back to memory
    as follows. If RFBM[_i_] = 1, XSAVE writes XSTATE_BV[_i_] with the
    value of XINUSE[_i_]. (XINUSE is a bitmap by which the processor
    tracks the status of various state components. See Section 13.6,
    “Processor Tracking of XSAVE-Managed State.”) If RFBM[_i_] = 0,
    XSAVE writes XSTATE_BV[_i_] with the value that it read from memory
    (it does not modify the bit). XSAVE does not write to any part of
    the XSAVE header other than the XSTATE_BV field.
-   XSAVE always uses the standard format of the extended region of the
    XSAVE area (see Section 13.4.3, “Extended Region of an XSAVE Area”).

  1. An exception is made for MXCSR and MXCSR_MASK, which belong to
  state component 1 — SSE. XSAVE saves these values to memory if either
  RFBM[1] or RFBM[2] is 1.

Use of a destination operand not aligned to 64-byte boundary (in either
64-bit or 32-bit modes) results in a general-protection (#GP) exception.
In 64-bit mode, the upper 32 bits of RDX and RAX are ignored.


Operation¶

    RFBM ← XCR0 AND EDX:EAX; /* bitwise logical AND */
    OLD_BV ← XSTATE_BV field from XSAVE header;
    IF RFBM[0] = 1
        THEN store x87 state into legacy region of XSAVE area;
    FI;
    IF RFBM[1] = 1

        THEN store XMM registers into legacy region of XSAVE area; // this step does not save MXCSR or MXCSR_MASK
    FI;
    IF RFBM[1] = 1 OR RFBM[2] = 1
        THEN store MXCSR and MXCSR_MASK into legacy region of XSAVE area;
    FI;
    FOR i ← 2 TO 62
        IF RFBM[i] = 1
            THEN save XSAVE state component i at offset n from base of XSAVE area (n enumerated by CPUID(EAX=0DH,ECX=i):EBX);
        FI;
    ENDFOR;
    XSTATE_BV field in XSAVE header ← (OLD_BV AND NOT RFBM) OR (XINUSE AND RFBM);


Flags Affected¶

None.


Intel C/C++ Compiler Intrinsic Equivalent¶

    XSAVE: void _xsave( void * , unsigned __int64);

    XSAVE: void _xsave64( void * , unsigned __int64);


Protected Mode Exceptions¶

#GP(0)

If a memory operand effective address is outside the CS, DS, ES, FS, or
GS segment limit.

If a memory operand is not aligned on a 64-byte boundary, regardless of
segment.

#SS(0)

If a memory operand effective address is outside the SS segment limit.

#PF(fault-code)

If a page fault occurs.

#NM

If CR0.TS[bit 3] = 1.

#UD

If CPUID.01H:ECX.XSAVE[bit 26] = 0.

If CR4.OSXSAVE[bit 18] = 0.

If the LOCK prefix is used.

#AC

If this exception is disabled a general protection exception (#GP) is
signaled if the memory operand is not aligned on a 64-byte boundary, as
described above. If the alignment check exception (#AC) is enabled (and
the CPL is 3), signaling of #AC is not guaranteed and may vary with
implementation, as follows. In all implementations where #AC is not
signaled, a general protection exception is signaled in its place. In
addition, the width of the alignment check may also vary with
implementation. For instance, for a given implementation, an alignment
check exception might be signaled for a 2-byte misalignment, whereas a
general protection exception might be signaled for all other
misalignments (4-, 8-, or 16-byte misalignments).


Real-Address Mode Exceptions¶

#GP

If a memory operand is not aligned on a 64-byte boundary, regardless of
segment.

If any part of the operand lies outside the effective address space from
0 to FFFFH.

#NM

If CR0.TS[bit 3] = 1.

#UD

If CPUID.01H:ECX.XSAVE[bit 26] = 0.

If CR4.OSXSAVE[bit 18] = 0.

If the LOCK prefix is used.


Virtual-8086 Mode Exceptions¶

Same exceptions as in protected mode.


Compatibility Mode Exceptions¶

Same exceptions as in protected mode.


64-Bit Mode Exceptions¶

#GP(0)

If the memory address is in a non-canonical form.

If a memory operand is not aligned on a 64-byte boundary, regardless of
segment.

#SS(0)

If a memory address referencing the SS segment is in a non-canonical
form.

#PF(fault-code)

If a page fault occurs.

#NM

If CR0.TS[bit 3] = 1.

#UD

If CPUID.01H:ECX.XSAVE[bit 26] = 0.

If CR4.OSXSAVE[bit 18] = 0.

If the LOCK prefix is used.

#AC

If this exception is disabled a general protection exception (#GP) is
signaled if the memory operand is not aligned on a 64-byte boundary, as
described above. If the alignment check exception (#AC) is enabled (and
the CPL is 3), signaling of #AC is not guaranteed and may vary with
implementation, as follows. In all implementations where #AC is not
signaled, a general protection exception is signaled in its place. In
addition, the width of the alignment check may also vary with
implementation. For instance, for a given implementation, an alignment
check exception might be signaled for a 2-byte misalignment, whereas a
general protection exception might be signaled for all other
misalignments (4-, 8-, or 16-byte misalignments).

This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be incomplete or b_(r)oke_(n) in
various obvious or non-obvious ways. Refer to Intel® 64 and IA-32
Architectures Software Developer’s Manual for anything serious.
