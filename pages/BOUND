-   Index
-   May 2019



BOUND — CHECK ARRAY INDEX AGAINST BOUNDS


  Opcode   Instruction           Op/En   64-bit Mode   Compat/Leg Mode   Description
  -------- --------------------- ------- ------------- ----------------- ----------------------------------------------------------------------
  62 /r    BOUND _r16, m16&16_   RM      Invalid       Valid             Check if _r16_ (array index) is within bounds specified by _m16&16._
  62 /r    BOUND _r32, m32&32_   RM      Invalid       Valid             Check if _r32_ (array index) is within bounds specified by _m32&32._


Instruction Operand Encoding ¶

  ------- --------------- --------------- ----------- -----------
  Op/En   Operand 1       Operand 2       Operand 3   Operand 4
  RM      ModRM:reg (r)   ModRM:r/m (r)   NA          NA
  ------- --------------- --------------- ----------- -----------


Description ¶

BOUND determines if the first operand (array index) is within the bounds
of an array specified the second operand (bounds operand). The array
index is a signed integer located in a register. The bounds operand is a
memory location that contains a pair of signed doubleword-integers (when
the operand-size attribute is 32) or a pair of signed word-integers
(when the operand-size attribute is 16). The first doubleword (or word)
is the lower bound of the array and the second doubleword (or word) is
the upper bound of the array. The array index must be greater than or
equal to the lower bound and less than or equal to the upper bound plus
the operand size in bytes. If the index is not within bounds, a BOUND
range exceeded exception (#BR) is signaled. When this exception is
generated, the saved return instruction pointer points to the BOUND
instruction.

The bounds limit data structure (two words or doublewords containing the
lower and upper limits of the array) is usually placed just before the
array itself, making the limits addressable via a constant offset from
the beginning of the array. Because the address of the array already
will be present in a register, this practice avoids extra bus cycles to
obtain the effective address of the array bounds.

This instruction executes as described in compatibility mode and legacy
mode. It is not valid in 64-bit mode.


Operation ¶

    IF 64bit Mode
        THEN
            #UD;
        ELSE
            IF (ArrayIndex < LowerBound OR ArrayIndex > UpperBound) THEN
            (* Below lower bound or above upper bound *)
                IF <equation for PL enabled> THEN BNDSTATUS ← 0
                #BR;
            FI;
    FI;


Flags Affected ¶

None.


Protected Mode Exceptions ¶

#BR

If the bounds test fails.

#UD

If second operand is not a memory location.

If the LOCK prefix is used.

#GP(0)

If a memory operand effective address is outside the CS, DS, ES, FS, or
GS segment limit.

If the DS, ES, FS, or GS register contains a NULL segment selector.

#SS(0)

If a memory operand effective address is outside the SS segment limit.

#PF(fault-code)

If a page fault occurs.

#AC(0)

If alignment checking is enabled and an unaligned memory reference is
made while the current privilege level is 3.


Real-Address Mode Exceptions ¶

#BR

If the bounds test fails.

#UD

If second operand is not a memory location.

If the LOCK prefix is used.

#GP

If a memory operand effective address is outside the CS, DS, ES, FS, or
GS segment limit.

#SS

If a memory operand effective address is outside the SS segment limit.


Virtual-8086 Mode Exceptions ¶

#BR

If the bounds test fails.

#UD

If second operand is not a memory location.

If the LOCK prefix is used.

#GP(0)

If a memory operand effective address is outside the CS, DS, ES, FS, or
GS segment limit.

#SS(0)

If a memory operand effective address is outside the SS segment limit.

#PF(fault-code)

If a page fault occurs.

#AC(0)

If alignment checking is enabled and an unaligned memory reference is
made.


Compatibility Mode Exceptions ¶

Same exceptions as in protected mode.


64-Bit Mode Exceptions ¶

  ----- --------------------
  #UD   If in 64-bit mode.
  ----- --------------------

This UNOFFICIAL, mechanically-separated, non-verified reference is
provided for convenience, but it may be incomplete or b_(r)oke_(n) in
various obvious or non-obvious ways. Refer to Intel® 64 and IA-32
Architectures Software Developer’s Manual for anything serious.
